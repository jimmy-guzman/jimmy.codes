---
title: Two Sum
publishDate: 2025-08-10
description: "Solutions for finding two numbers that add up to a target."
keywords: ["two sum", "algorithm", "hash map", "for of", "coding challenge"]
---

## Prompt

> Given an array of integers and an integer target, return the indices of the two numbers such that they add up to target. You may assume exactly one solution exists.

### Tests

```ts
describe("twoSum", () => {
  it("should return the correct indices for a valid input", () => {
    expect(twoSum([2, 7, 11, 15], 9)).toStrictEqual([0, 1]);
  });

  it("should handle negative numbers", () => {
    expect(twoSum([-3, 4, 3, 90], 0)).toStrictEqual([0, 2]);
  });

  it("should handle duplicate numbers", () => {
    expect(twoSum([3, 2, 4], 6)).toStrictEqual([1, 2]);
  });

  it("should fallback to placeholder values when no solution is found", () => {
    expect(twoSum([1, 2, 3], 7)).toStrictEqual([-1, -1]);
  });
});
```

### Solutions

#### Hash Map

This solution uses a hash map to store previously seen integers and their indices.
As we iterate through the array, we calculate the complement needed to reach the target and check if it exists in the map. If it does, we return the indices.

_Complexity: O(n) time, O(n) space._

```ts twoslash
/**
 * Find two distinct indices in the array whose values add up to the target.
 * @example
 * twoSum([2, 7, 11, 15], 9); // returns [0, 1]
 */
function twoSum(integers: number[], target: number) {
  // Map to store number → index for O(1) complement lookups.
  const seen = new Map<number, number>();

  // Loop through the array once.
  for (let i = 0; i < integers.length; i++) {
    const current = integers[i];

    // The number we still need to reach the target.
    const complement = target - current;

    // If we've seen the complement before, return its index and current index.
    if (seen.has(complement)) {
      return [seen.get(complement)!, i] as const;
    }

    // Otherwise, store the current number for future checks.
    seen.set(current, i);
  }

  // Shouldn't be reached per problem statement, but included for safety.
  return [-1, -1] as const;
}
```

#### For-of Loop

This solution uses a `for-of` loop to iterate through the array.
For each element, it calculates the complement and checks if it exists in the remaining part of the array.

_Complexity: O(n²) time, O(1) space._

```ts twoslash
/**
 * Find two distinct indices in the array whose values add up to the target.
 * @example
 * twoSum([2, 7, 11, 15], 9); // returns [0, 1]
 */
function twoSum(integers: number[], target: number) {
  // Loop through the array with index and value.
  for (const [i, current] of integers.entries()) {
    // The number we still need to reach the target.
    const complement = target - current;

    // If the complement exists later in the array, return both indices.
    if (integers.includes(complement, i + 1)) {
      return [i, integers.indexOf(complement, i + 1)] as const;
    }
  }

  // Shouldn't be reached per problem statement, but included for safety.
  return [-1, -1] as const;
}
```

## Conclusion

The Two Sum prompt tests your ability to efficiently find a pair of numbers that add up to a given target.

Both solutions are valid, but:

- **Hash Map:** O(n) time, O(n) space — best all-around for performance.
- **For-of Loop:** O(n²) time, O(1) space — simpler, but slower for large arrays.
