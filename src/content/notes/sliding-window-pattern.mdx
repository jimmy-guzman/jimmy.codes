---
title: Sliding Window Pattern
publishDate: 2025-08-10
description: "Solutions for solving substring and subarray problems efficiently with the sliding window pattern."
keywords: ["sliding window", "algorithm", "two pointers", "coding challenge"]
---

## Prompt

Given a string `s`, find the length of the longest substring without repeating characters.

## Key Ideas

- Use two pointers (`left` and `right`) to represent a sliding window.
- Adjust the window to maintain the “no repeating characters” constraint.
- **Set** → delete characters from the left until valid.
- **Map** → jump `left` past the last duplicate’s index.

---

## Tests

{/* cspell:disable */}

- `"abcabcbb"` → `3` (`abc`)
- `""` → `0`
- `"bbbbb"` → `1` (`b`)
- `"abcdefg"` → `7` (all unique)
- `"pwwkew"` → `3` (`wke`)
- `"abba"` → `2` (`ab` or `ba`)
- `"dvdf"` → `3` (`vdf`)

{/* cspell:enable */}

---

## Set-based — O(n) time, O(min(m, n)) space

_Mental model:_ Expand `right` adding characters; shrink from `left` until window has no duplicates.

```ts
function lengthOfLongestSubstring(s: string) {
  const window = new Set<string>();
  let left = 0;
  let best = 0;

  for (let right = 0; right < s.length; right++) {
    const character = s[right];

    while (window.has(character)) {
      window.delete(s[left++]);
    }

    window.add(character);

    best = Math.max(best, right - left + 1);
  }

  return best;
}
```

---

## Map-based — O(n) time, O(min(m, n)) space

_Mental model:_ Track last index of each char; jump `left` past duplicates in one step.

```ts
function lengthOfLongestSubstring(s: string) {
  const window = new Map<string, number>();
  let left = 0;
  let best = 0;

  for (let right = 0; right < s.length; right++) {
    const character = s[right];

    if (window.has(character)) {
      left = Math.max(left, window.get(character)! + 1);
    }

    window.set(character, right);

    best = Math.max(best, right - left + 1);
  }

  return best;
}
```

---

## Variants

- Longest substring **with at most k distinct characters**.
- Longest substring **with exactly k distinct characters**.
- Longest substring matching a pattern (sliding window + frequency map).
- Longest subarray sum ≤ target (same two-pointer pattern, numeric arrays).
- Smallest substring containing all chars of another string.

---

## Takeaways

- **Set** → simpler logic, may delete multiple times for repeats.
- **Map** → fewer deletions, better for clustered duplicates.
